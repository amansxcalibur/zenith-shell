import colorsys
from pathlib import Path
from loguru import logger

from config.info import ROOT_DIR
from config.config import config
from config.bindings import KeyBinding, I3_KEYBINDINGS
from utils.colors import get_css_variable, hex_to_rgb01

from fabric.i3.widgets import get_i3_connection
# from fabric.i3.service import I3MessageType, I3Error

CONFIG_DIR = Path.home() / ".config/i3"
CONFIG_PATH = CONFIG_DIR / "config"
CONFIG_GLOB_PATH = Path.home() / ".config/i3/conf.d"
BORDERS_CONF_PATH = CONFIG_GLOB_PATH / "borders.conf"
KEYBINDS_CONF_PATH = CONFIG_GLOB_PATH / "keybinds.conf"
GENERAL_CONF_PATH = CONFIG_GLOB_PATH / "general.conf"


def _reload_i3():
    try:
        i3_resp = get_i3_connection().send_command("reload")
        success = all(
            r.get("success", False) for r in i3_resp.reply if isinstance(r, dict)
        )
        if not success:
            logger.error("i3 config failed to reload: {}", i3_resp.reply)
    except Exception as e:
        logger.error("Error reloading i3 config: {}", e)


# Temporary workaround until my rounded-corners i3 patch is ready and picom shadows work as expected.
def ensure_vibrancy(hex_color: str, min_brightness=0.8, min_saturation=0.5) -> str:
    """Boosts brightness and saturation to ensure it stands out against backgrounds."""
    hex_color = hex_color.lstrip("#")

    # Hex -> RGB -> HSV
    r, g, b = hex_to_rgb01(hex_color=hex_color)
    h, s, v = colorsys.rgb_to_hsv(r, g, b)

    # Boost brightness and saturation if they are below threshold
    new_v = max(v, min_brightness)
    new_s = max(s, min_saturation)

    # HSV -> RGB -> Hex
    r, g, b = colorsys.hsv_to_rgb(h, new_s, new_v)
    return "#{:02x}{:02x}{:02x}".format(int(r * 255), int(g * 255), int(b * 255))


def generate_i3_border_theme_config(hex_color: str = None, reload: bool = False):
    ensure_i3_paths()
    STYLES_DIR = ROOT_DIR / "styles"
    COLORS_CSS_PATH = STYLES_DIR / "colors.css"

    theme_available = True

    if hex_color is None:
        if COLORS_CSS_PATH.exists():
            raw_color = get_css_variable(str(COLORS_CSS_PATH), "--primary")
            # raw_color = ensure_vibrancy(raw_color)
            hex_color = raw_color
        else:
            hex_color = "#5e81ac"
            theme_available = False

    logger.debug("Setting i3 focused border color to {}", hex_color)

    border_conf = [
        "# CAUTION: This file has been auto-generated by Zenith Shell.",
        "# Any manual changes WILL BE OVERWRITTEN on the next startup.",
        "# To change these bindings, use Settings or edit:",
        f"#   {ROOT_DIR}/config/config.json  OR",
        f"#   {ROOT_DIR}/config/i3/utils.py  OR",
        "",
        f"{'' if (theme_available and config.i3.borders.matugen_enable) else '# '}client.focused          {hex_color} {hex_color} {hex_color} {hex_color}",
        "# client.focused_inactive #ff0000 #ff0000 #ff0000 #ff0000",
        "# client.unfocused        #ff0000 #ff0000 #ff0000 #ff0000",
        "# client.urgent           #ff0000 #ff0000 #ff0000 #ff0000",
    ]

    with open(BORDERS_CONF_PATH, "w") as f:
        f.write("\n".join(border_conf))

    if reload:
        _reload_i3()


def validate_keybindings(bindings: list[KeyBinding]) -> None:
    seen_keys = set()

    for b in bindings:
        if not b.key:
            raise ValueError(f"Missing key for action {b.action}")

        if b.key in seen_keys:
            raise ValueError(f"Duplicate keybinding: {b.key}")

        seen_keys.add(b.key)


def generate_i3_keybinds(bindings: list[KeyBinding]) -> str:
    lines = [
        "# CAUTION: This file has been auto-generated by Zenith Shell.",
        "# Any manual changes WILL BE OVERWRITTEN on the next startup.",
        "# To change these bindings, edit I3_KEYBINDINGS in:",
        f"#   {ROOT_DIR}/config/bindings.py",
        "",
    ]

    for b in bindings:
        lines.append(f"bindsym {b.key} exec --no-startup-id {b.command}")

    return "\n".join(lines)


def ensure_i3_config_includes_glob_dir(config_path: Path, include_dir: Path):
    include_line = f"include {include_dir}/*.conf"

    if not config_path.exists():
        logger.warning(f"i3 config not found at {config_path}. Creating new one.")
        config_path.write_text(f"{include_line}\n")
        return

    content = config_path.read_text()

    if include_line not in content:
        logger.info("Adding include line to i3 config")
        # start on a new line
        suffix = "\n" if not content.endswith("\n") else ""
        with open(config_path, "a") as f:
            f.write(f"{suffix}# globbing - all .conf in /conf.d\n{include_line}\n")
    else:
        logger.debug("i3 config already contains include line")


def get_i3_config_path() -> Path:
    # Commented this out because I dont wanna be making changes
    # to configs that are not intended to me touched...
    # try:
    #     conn = get_i3_connection()

    #     # Send the GET_VERSION request
    #     reply = conn.send_command("", I3MessageType.GET_VERSION)

    #     if reply.is_ok and isinstance(reply.reply, dict):
    #         # Extract the path from the reply dictionary
    #         path_str = reply.reply.get("loaded_config_file_name")
    #         if path_str:
    #             return Path(path_str)

    #     raise I3Error("Path not found in IPC version reply")

    # except Exception as e:
    #     logger.error(f"Could not determine i3 config path via IPC: {e}")
    #     # Fallback to the most common default
    #     return Path("~/.config/i3/config").expanduser()

    return CONFIG_PATH
    
def ensure_i3_paths():
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_GLOB_PATH.mkdir(parents=True, exist_ok=True)



def generate_i3_keybinds_config(reload: bool = False):
    logger.debug("Setting i3 keybinds")

    ensure_i3_paths()
    main_config_path = get_i3_config_path()

    try:
        ensure_i3_config_includes_glob_dir(main_config_path, CONFIG_GLOB_PATH)
        validate_keybindings(I3_KEYBINDINGS)
        config = generate_i3_keybinds(I3_KEYBINDINGS)

        with open(KEYBINDS_CONF_PATH, "w") as f:
            f.write(config)

        if reload:
            _reload_i3()

    except Exception as e:
        logger.error("Failed to apply keybindings: {}", e)


def generate_i3_gaps_and_borders_config():
    lines = []

    gaps_config = config.i3.gaps
    if gaps_config.enable:
        lines.append("# gaps")
        for prop, val in gaps_config.props.get_all().items():
            lines.append(f"gaps {prop} {val}px")
        lines.append("")

    border_config = config.i3.borders
    if border_config.enable:
        lines.append("# borders")
        lines.append(f"default_border pixel {border_config.props.border_width}")
        lines.append("default_floating_border none")
        lines.append("")

    if config.i3.smart_borders.enable:
        lines.append("smart_borders on")
        lines.append("")

    return "\n".join(lines)


def generate_i3_general_config(reload: bool = False):
    ensure_i3_paths()
    main_config_path = get_i3_config_path()

    lines = [
        "# CAUTION: This file has been auto-generated by Zenith Shell.",
        "# Any manual changes WILL BE OVERWRITTEN on the next startup.",
        "# To change these bindings, edit:",
        f"#   {ROOT_DIR}/config/config.json",
        "",
    ]

    try:
        ensure_i3_config_includes_glob_dir(main_config_path, CONFIG_GLOB_PATH)

        logger.debug("Applying i3 kill exceptions for zenith")
        lines.extend(
            [
                "# kill focused window (except zenith)",
                'bindsym $mod+Shift+q [con_id="__focused__" instance="^(?!zenith-core).*$"] kill',
                "",
            ]
        )

        logger.debug("Setting i3 borders and gaps")
        lines.append(generate_i3_gaps_and_borders_config())

        with open(GENERAL_CONF_PATH, "w") as f:
            f.write("\n".join(lines) + "\n")

        if reload:
            _reload_i3()

    except Exception as e:
        logger.error("Failed to generate i3 general config: {}", e)
